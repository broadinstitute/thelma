package bootstrap

import (
	"fmt"
	config "github.com/broadinstitute/thelma/internal/thelma/app/config"
	"github.com/broadinstitute/thelma/internal/thelma/app/root"
	"github.com/broadinstitute/thelma/internal/thelma/utils"
	"github.com/broadinstitute/thelma/internal/thelma/utils/prompt/mocks"
	"github.com/broadinstitute/thelma/internal/thelma/utils/shell"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	"os"
	"path"
	"strings"
	"testing"
)

type BootstrapSuite struct {
	suite.Suite
	root                      root.Root
	config                    config.Config
	runner                    *shell.MockRunner
	prompt                    *mocks.Prompt
	bootstrapper              Bootstrapper
	zshrcPath                 string
	configFilePath            string
	shellCompletionScriptPath string
	initScriptPath            string
}

func TestBootstrapper(t *testing.T) {
	suite.Run(t, new(BootstrapSuite))
}

func (suite *BootstrapSuite) SetupTest() {
	var err error

	t := suite.T()
	suite.root = root.NewAt(t.TempDir())
	require.NoError(t, suite.root.CreateDirectories())

	suite.config, err = config.NewTestConfig(t)
	require.NoError(t, err)

	suite.runner = shell.DefaultMockRunner()
	suite.prompt = mocks.NewPrompt(t)
	suite.zshrcPath = path.Join(t.TempDir(), zshrcFile)

	suite.bootstrapper = newWith(suite.root, suite.config, suite.runner, suite.prompt, suite.zshrcPath)

	suite.configFilePath = path.Join(suite.root.Dir(), "config.yaml")
	suite.shellCompletionScriptPath = path.Join(suite.root.ShellDir(), thelmaShellCompletionFile)
	suite.initScriptPath = path.Join(suite.root.ShellDir(), thelmaInitializationFile)

	suite.expectWelcomeMessage()
}

func (suite *BootstrapSuite) TestBootstrapFullInstallWithDefaults() {
	suite.setUserInput(true, true)
	suite.expectShellCompletionCommand("fake shell completion script")

	require.NoError(suite.T(), suite.bootstrapper.Bootstrap())

	suite.verifyConfigFile()
	suite.verifyShellCompletionScript("fake shell completion script")
	suite.verifyInitScript(`#
# Thelma shell initialization file
#
# This file was auto-generated by +thelma update --bootstrap+; do not edit!
#

# Add +thelma+ to PATH
export PATH="<ROOT>/releases/current/bin:${PATH}"

# Add Thelma bundled tools (helmfile, helm, kubectl, etc) to PATH
export PATH="<ROOT>/releases/current/tools/bin:${PATH}"

# Enable shell completion for +thelma+
source <ROOT>/shell/completion.zsh && compdef _thelma thelma
`)
	suite.verifyZshrcUpdated()
}

func (suite *BootstrapSuite) TestBootstrapDoesNotAddShellCompletionIfNotSelected() {
	suite.setUserInput(true, false)

	require.NoError(suite.T(), suite.bootstrapper.Bootstrap())

	assert.NoFileExists(suite.T(), suite.shellCompletionScriptPath)

	suite.assertFileContent(suite.initScriptPath, `#
# Thelma shell initialization file
#
# This file was auto-generated by +thelma update --bootstrap+; do not edit!
#

# Add +thelma+ to PATH
export PATH="<ROOT>/releases/current/bin:${PATH}"

# Add Thelma bundled tools (helmfile, helm, kubectl, etc) to PATH
export PATH="<ROOT>/releases/current/tools/bin:${PATH}"
`)
}

func (suite *BootstrapSuite) TestBootstrapDoesNotAddToolsToPathIfNotSelected() {
	suite.setUserInput(false, true)
	suite.expectShellCompletionCommand("fake shell completion script")

	require.NoError(suite.T(), suite.bootstrapper.Bootstrap())

	suite.assertFileContent(suite.initScriptPath, `#
# Thelma shell initialization file
#
# This file was auto-generated by +thelma update --bootstrap+; do not edit!
#

# Add +thelma+ to PATH
export PATH="<ROOT>/releases/current/bin:${PATH}"

# Enable shell completion for +thelma+
source <ROOT>/shell/completion.zsh && compdef _thelma thelma
`)
}

func (suite *BootstrapSuite) TestBootstrapDoesNotAddToolsToPathOrAddShellCompletionIfNotSelected() {
	suite.setUserInput(false, false)

	require.NoError(suite.T(), suite.bootstrapper.Bootstrap())

	suite.verifyInitScript(`#
# Thelma shell initialization file
#
# This file was auto-generated by +thelma update --bootstrap+; do not edit!
#

# Add +thelma+ to PATH
export PATH="<ROOT>/releases/current/bin:${PATH}"
`)
}

func (suite *BootstrapSuite) TestBootstrapBacksUpZshrc() {
	suite.setUserInput(false, false)

	content := []byte("A fake zshrc with stuff in it\n")
	err := os.WriteFile(suite.zshrcPath, content, 0644)
	require.NoError(suite.T(), err)

	require.NoError(suite.T(), suite.bootstrapper.Bootstrap())

	zshrcDir := path.Dir(suite.zshrcPath)
	entries, err := os.ReadDir(zshrcDir)
	require.NoError(suite.T(), err)
	assert.Equal(suite.T(), 2, len(entries))

	backupFile := path.Join(zshrcDir, entries[1].Name())
	assert.Regexp(suite.T(), `.*\/\.zshrc.\d{8}\.\d{6}$`, backupFile)

	suite.assertFileContent(backupFile, "A fake zshrc with stuff in it\n")
}

func (suite *BootstrapSuite) TestBootstrapDoesNotUpdateZshrcIfContainsThelmaReference() {
	suite.setUserInput(false, false)

	// create fake .zshrc with a thelma reference in it
	content := []byte("A fake zshrc that includes the string `thelma`\n")
	err := os.WriteFile(suite.zshrcPath, content, 0644)
	require.NoError(suite.T(), err)

	// expect the fragment to be printed out to console
	expectedFragment := suite.normalizeTestFileContent(`
# Thelma initialization
if [ -f "<ROOT>/shell/init.zsh" ]; then . "<ROOT>/shell/init.zsh"; fi

`)
	suite.prompt.EXPECT().Print(expectedFragment, mock.Anything)

	// run bootstrap
	require.NoError(suite.T(), suite.bootstrapper.Bootstrap())

	// make sure zshrc was not changed
	suite.assertFileContent(suite.zshrcPath, string(content))
}

func (suite *BootstrapSuite) setUserInput(addToolsToPath bool, shellCompletion bool) {
	suite.prompt.EXPECT().Newline().Return(nil)
	suite.prompt.EXPECT().Confirm(addToolsToPathPrompt, mock.Anything).Return(addToolsToPath, nil)
	suite.prompt.EXPECT().Confirm(enableShellCompletionPrompt, mock.Anything).Return(shellCompletion, nil)
	suite.prompt.EXPECT().Newline().Return(nil)
}

func (suite *BootstrapSuite) expectShellCompletionCommand(output string) {
	executable, err := utils.PathToRunningThelmaExecutable()
	require.NoError(suite.T(), err)
	suite.runner.ExpectCmd(shell.Command{
		Prog: executable,
		Args: []string{"completion", "zsh"},
	}).WithStdout(output)
}

func (suite *BootstrapSuite) verifyConfigFile() {
	suite.assertFileContent(suite.configFilePath, fmt.Sprintf(`#
# Thelma configuration file
#

# path to terra-helmfile git clone
home: %s
`, suite.config.Home()))
}

func (suite *BootstrapSuite) verifyShellCompletionScript(content string) {
	suite.assertFileContent(suite.shellCompletionScriptPath, content)
}

func (suite *BootstrapSuite) verifyInitScript(content string) {
	suite.assertFileContent(suite.initScriptPath, content)
}

func (suite *BootstrapSuite) verifyZshrcUpdated() {
	assert.FileExists(suite.T(), suite.zshrcPath)

	expectedFragment := suite.normalizeTestFileContent(`
# Thelma initialization
if [ -f "<ROOT>/shell/init.zsh" ]; then . "<ROOT>/shell/init.zsh"; fi

`)

	actualContent, err := os.ReadFile(suite.zshrcPath)
	require.NoError(suite.T(), err)

	assert.Contains(suite.T(), string(actualContent), expectedFragment)
}

func (suite *BootstrapSuite) expectWelcomeMessage() {
	suite.prompt.EXPECT().Newline(2).Return(nil)
	suite.prompt.EXPECT().Print(asciiLogo, mock.Anything).Return(nil)
	suite.prompt.EXPECT().Newline(2)
	suite.prompt.EXPECT().Print(welcomeMessage).Return(nil)
	suite.prompt.EXPECT().Newline(2)
}

func (suite *BootstrapSuite) assertFileContent(file string, expectedContent string) {
	assert.FileExists(suite.T(), file)

	content, err := os.ReadFile(file)
	require.NoError(suite.T(), err)

	expectedContent = suite.normalizeTestFileContent(expectedContent)

	assert.Equal(suite.T(), expectedContent, string(content), "%s has incorrect content", file)
}

func (suite *BootstrapSuite) normalizeTestFileContent(expectedContent string) string {
	// replace + with ` since some templates contain ` and we
	// can't use ` in raw string literals
	expectedContent = strings.ReplaceAll(expectedContent, "+", "`")

	// replace <ROOT> with our test's fake thelma root dir (randomly generated)
	expectedContent = strings.ReplaceAll(expectedContent, "<ROOT>", suite.root.Dir())
	return expectedContent
}
