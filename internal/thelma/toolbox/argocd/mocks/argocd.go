// Code generated by mockery v2.40.1. DO NOT EDIT.

package mocks

import (
	argocd "github.com/broadinstitute/thelma/internal/thelma/toolbox/argocd"
	mock "github.com/stretchr/testify/mock"

	terra "github.com/broadinstitute/thelma/internal/thelma/state/api/terra"
)

// ArgoCD is an autogenerated mock type for the ArgoCD type
type ArgoCD struct {
	mock.Mock
}

type ArgoCD_Expecter struct {
	mock *mock.Mock
}

func (_m *ArgoCD) EXPECT() *ArgoCD_Expecter {
	return &ArgoCD_Expecter{mock: &_m.Mock}
}

// AppStatus provides a mock function with given fields: appName
func (_m *ArgoCD) AppStatus(appName string) (argocd.ApplicationStatus, error) {
	ret := _m.Called(appName)

	if len(ret) == 0 {
		panic("no return value specified for AppStatus")
	}

	var r0 argocd.ApplicationStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (argocd.ApplicationStatus, error)); ok {
		return rf(appName)
	}
	if rf, ok := ret.Get(0).(func(string) argocd.ApplicationStatus); ok {
		r0 = rf(appName)
	} else {
		r0 = ret.Get(0).(argocd.ApplicationStatus)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(appName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ArgoCD_AppStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AppStatus'
type ArgoCD_AppStatus_Call struct {
	*mock.Call
}

// AppStatus is a helper method to define mock.On call
//   - appName string
func (_e *ArgoCD_Expecter) AppStatus(appName interface{}) *ArgoCD_AppStatus_Call {
	return &ArgoCD_AppStatus_Call{Call: _e.mock.On("AppStatus", appName)}
}

func (_c *ArgoCD_AppStatus_Call) Run(run func(appName string)) *ArgoCD_AppStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ArgoCD_AppStatus_Call) Return(_a0 argocd.ApplicationStatus, _a1 error) *ArgoCD_AppStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ArgoCD_AppStatus_Call) RunAndReturn(run func(string) (argocd.ApplicationStatus, error)) *ArgoCD_AppStatus_Call {
	_c.Call.Return(run)
	return _c
}

// DefaultSyncOptions provides a mock function with given fields:
func (_m *ArgoCD) DefaultSyncOptions() argocd.SyncOptions {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DefaultSyncOptions")
	}

	var r0 argocd.SyncOptions
	if rf, ok := ret.Get(0).(func() argocd.SyncOptions); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(argocd.SyncOptions)
	}

	return r0
}

// ArgoCD_DefaultSyncOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DefaultSyncOptions'
type ArgoCD_DefaultSyncOptions_Call struct {
	*mock.Call
}

// DefaultSyncOptions is a helper method to define mock.On call
func (_e *ArgoCD_Expecter) DefaultSyncOptions() *ArgoCD_DefaultSyncOptions_Call {
	return &ArgoCD_DefaultSyncOptions_Call{Call: _e.mock.On("DefaultSyncOptions")}
}

func (_c *ArgoCD_DefaultSyncOptions_Call) Run(run func()) *ArgoCD_DefaultSyncOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ArgoCD_DefaultSyncOptions_Call) Return(_a0 argocd.SyncOptions) *ArgoCD_DefaultSyncOptions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ArgoCD_DefaultSyncOptions_Call) RunAndReturn(run func() argocd.SyncOptions) *ArgoCD_DefaultSyncOptions_Call {
	_c.Call.Return(run)
	return _c
}

// DestinationURL provides a mock function with given fields: dest
func (_m *ArgoCD) DestinationURL(dest terra.Destination) string {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for DestinationURL")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(terra.Destination) string); ok {
		r0 = rf(dest)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ArgoCD_DestinationURL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DestinationURL'
type ArgoCD_DestinationURL_Call struct {
	*mock.Call
}

// DestinationURL is a helper method to define mock.On call
//   - dest terra.Destination
func (_e *ArgoCD_Expecter) DestinationURL(dest interface{}) *ArgoCD_DestinationURL_Call {
	return &ArgoCD_DestinationURL_Call{Call: _e.mock.On("DestinationURL", dest)}
}

func (_c *ArgoCD_DestinationURL_Call) Run(run func(dest terra.Destination)) *ArgoCD_DestinationURL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(terra.Destination))
	})
	return _c
}

func (_c *ArgoCD_DestinationURL_Call) Return(_a0 string) *ArgoCD_DestinationURL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ArgoCD_DestinationURL_Call) RunAndReturn(run func(terra.Destination) string) *ArgoCD_DestinationURL_Call {
	_c.Call.Return(run)
	return _c
}

// HardRefresh provides a mock function with given fields: appName
func (_m *ArgoCD) HardRefresh(appName string) error {
	ret := _m.Called(appName)

	if len(ret) == 0 {
		panic("no return value specified for HardRefresh")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(appName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ArgoCD_HardRefresh_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HardRefresh'
type ArgoCD_HardRefresh_Call struct {
	*mock.Call
}

// HardRefresh is a helper method to define mock.On call
//   - appName string
func (_e *ArgoCD_Expecter) HardRefresh(appName interface{}) *ArgoCD_HardRefresh_Call {
	return &ArgoCD_HardRefresh_Call{Call: _e.mock.On("HardRefresh", appName)}
}

func (_c *ArgoCD_HardRefresh_Call) Run(run func(appName string)) *ArgoCD_HardRefresh_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *ArgoCD_HardRefresh_Call) Return(_a0 error) *ArgoCD_HardRefresh_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ArgoCD_HardRefresh_Call) RunAndReturn(run func(string) error) *ArgoCD_HardRefresh_Call {
	_c.Call.Return(run)
	return _c
}

// SyncApp provides a mock function with given fields: appName, options
func (_m *ArgoCD) SyncApp(appName string, options ...argocd.SyncOption) (argocd.SyncResult, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SyncApp")
	}

	var r0 argocd.SyncResult
	var r1 error
	if rf, ok := ret.Get(0).(func(string, ...argocd.SyncOption) (argocd.SyncResult, error)); ok {
		return rf(appName, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...argocd.SyncOption) argocd.SyncResult); ok {
		r0 = rf(appName, options...)
	} else {
		r0 = ret.Get(0).(argocd.SyncResult)
	}

	if rf, ok := ret.Get(1).(func(string, ...argocd.SyncOption) error); ok {
		r1 = rf(appName, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ArgoCD_SyncApp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncApp'
type ArgoCD_SyncApp_Call struct {
	*mock.Call
}

// SyncApp is a helper method to define mock.On call
//   - appName string
//   - options ...argocd.SyncOption
func (_e *ArgoCD_Expecter) SyncApp(appName interface{}, options ...interface{}) *ArgoCD_SyncApp_Call {
	return &ArgoCD_SyncApp_Call{Call: _e.mock.On("SyncApp",
		append([]interface{}{appName}, options...)...)}
}

func (_c *ArgoCD_SyncApp_Call) Run(run func(appName string, options ...argocd.SyncOption)) *ArgoCD_SyncApp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]argocd.SyncOption, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(argocd.SyncOption)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *ArgoCD_SyncApp_Call) Return(_a0 argocd.SyncResult, _a1 error) *ArgoCD_SyncApp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ArgoCD_SyncApp_Call) RunAndReturn(run func(string, ...argocd.SyncOption) (argocd.SyncResult, error)) *ArgoCD_SyncApp_Call {
	_c.Call.Return(run)
	return _c
}

// SyncRelease provides a mock function with given fields: release, options
func (_m *ArgoCD) SyncRelease(release terra.Release, options ...argocd.SyncOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, release)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SyncRelease")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(terra.Release, ...argocd.SyncOption) error); ok {
		r0 = rf(release, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ArgoCD_SyncRelease_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncRelease'
type ArgoCD_SyncRelease_Call struct {
	*mock.Call
}

// SyncRelease is a helper method to define mock.On call
//   - release terra.Release
//   - options ...argocd.SyncOption
func (_e *ArgoCD_Expecter) SyncRelease(release interface{}, options ...interface{}) *ArgoCD_SyncRelease_Call {
	return &ArgoCD_SyncRelease_Call{Call: _e.mock.On("SyncRelease",
		append([]interface{}{release}, options...)...)}
}

func (_c *ArgoCD_SyncRelease_Call) Run(run func(release terra.Release, options ...argocd.SyncOption)) *ArgoCD_SyncRelease_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]argocd.SyncOption, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(argocd.SyncOption)
			}
		}
		run(args[0].(terra.Release), variadicArgs...)
	})
	return _c
}

func (_c *ArgoCD_SyncRelease_Call) Return(_a0 error) *ArgoCD_SyncRelease_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ArgoCD_SyncRelease_Call) RunAndReturn(run func(terra.Release, ...argocd.SyncOption) error) *ArgoCD_SyncRelease_Call {
	_c.Call.Return(run)
	return _c
}

// WaitExist provides a mock function with given fields: appName, options
func (_m *ArgoCD) WaitExist(appName string, options ...argocd.WaitExistOption) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, appName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WaitExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, ...argocd.WaitExistOption) error); ok {
		r0 = rf(appName, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ArgoCD_WaitExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitExist'
type ArgoCD_WaitExist_Call struct {
	*mock.Call
}

// WaitExist is a helper method to define mock.On call
//   - appName string
//   - options ...argocd.WaitExistOption
func (_e *ArgoCD_Expecter) WaitExist(appName interface{}, options ...interface{}) *ArgoCD_WaitExist_Call {
	return &ArgoCD_WaitExist_Call{Call: _e.mock.On("WaitExist",
		append([]interface{}{appName}, options...)...)}
}

func (_c *ArgoCD_WaitExist_Call) Run(run func(appName string, options ...argocd.WaitExistOption)) *ArgoCD_WaitExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]argocd.WaitExistOption, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(argocd.WaitExistOption)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *ArgoCD_WaitExist_Call) Return(_a0 error) *ArgoCD_WaitExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ArgoCD_WaitExist_Call) RunAndReturn(run func(string, ...argocd.WaitExistOption) error) *ArgoCD_WaitExist_Call {
	_c.Call.Return(run)
	return _c
}

// NewArgoCD creates a new instance of ArgoCD. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewArgoCD(t interface {
	mock.TestingT
	Cleanup(func())
}) *ArgoCD {
	mock := &ArgoCD{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
