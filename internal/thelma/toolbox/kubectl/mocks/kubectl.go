// Code generated by mockery v2.15.0. DO NOT EDIT.

package mocks

import (
	kubecfg "github.com/broadinstitute/thelma/internal/thelma/clients/kubernetes/kubecfg"
	kubectl "github.com/broadinstitute/thelma/internal/thelma/toolbox/kubectl"

	mock "github.com/stretchr/testify/mock"

	shell "github.com/broadinstitute/thelma/internal/thelma/utils/shell"

	terra "github.com/broadinstitute/thelma/internal/thelma/state/api/terra"
)

// Kubectl is an autogenerated mock type for the Kubectl type
type Kubectl struct {
	mock.Mock
}

type Kubectl_Expecter struct {
	mock *mock.Mock
}

func (_m *Kubectl) EXPECT() *Kubectl_Expecter {
	return &Kubectl_Expecter{mock: &_m.Mock}
}

// CreateNamespace provides a mock function with given fields: env
func (_m *Kubectl) CreateNamespace(env terra.Environment) error {
	ret := _m.Called(env)

	var r0 error
	if rf, ok := ret.Get(0).(func(terra.Environment) error); ok {
		r0 = rf(env)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Kubectl_CreateNamespace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNamespace'
type Kubectl_CreateNamespace_Call struct {
	*mock.Call
}

// CreateNamespace is a helper method to define mock.On call
//   - env terra.Environment
func (_e *Kubectl_Expecter) CreateNamespace(env interface{}) *Kubectl_CreateNamespace_Call {
	return &Kubectl_CreateNamespace_Call{Call: _e.mock.On("CreateNamespace", env)}
}

func (_c *Kubectl_CreateNamespace_Call) Run(run func(env terra.Environment)) *Kubectl_CreateNamespace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(terra.Environment))
	})
	return _c
}

func (_c *Kubectl_CreateNamespace_Call) Return(_a0 error) *Kubectl_CreateNamespace_Call {
	_c.Call.Return(_a0)
	return _c
}

// DeleteNamespace provides a mock function with given fields: env
func (_m *Kubectl) DeleteNamespace(env terra.Environment) error {
	ret := _m.Called(env)

	var r0 error
	if rf, ok := ret.Get(0).(func(terra.Environment) error); ok {
		r0 = rf(env)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Kubectl_DeleteNamespace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNamespace'
type Kubectl_DeleteNamespace_Call struct {
	*mock.Call
}

// DeleteNamespace is a helper method to define mock.On call
//   - env terra.Environment
func (_e *Kubectl_Expecter) DeleteNamespace(env interface{}) *Kubectl_DeleteNamespace_Call {
	return &Kubectl_DeleteNamespace_Call{Call: _e.mock.On("DeleteNamespace", env)}
}

func (_c *Kubectl_DeleteNamespace_Call) Run(run func(env terra.Environment)) *Kubectl_DeleteNamespace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(terra.Environment))
	})
	return _c
}

func (_c *Kubectl_DeleteNamespace_Call) Return(_a0 error) *Kubectl_DeleteNamespace_Call {
	_c.Call.Return(_a0)
	return _c
}

// DeletePVCs provides a mock function with given fields: env
func (_m *Kubectl) DeletePVCs(env terra.Environment) error {
	ret := _m.Called(env)

	var r0 error
	if rf, ok := ret.Get(0).(func(terra.Environment) error); ok {
		r0 = rf(env)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Kubectl_DeletePVCs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePVCs'
type Kubectl_DeletePVCs_Call struct {
	*mock.Call
}

// DeletePVCs is a helper method to define mock.On call
//   - env terra.Environment
func (_e *Kubectl_Expecter) DeletePVCs(env interface{}) *Kubectl_DeletePVCs_Call {
	return &Kubectl_DeletePVCs_Call{Call: _e.mock.On("DeletePVCs", env)}
}

func (_c *Kubectl_DeletePVCs_Call) Run(run func(env terra.Environment)) *Kubectl_DeletePVCs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(terra.Environment))
	})
	return _c
}

func (_c *Kubectl_DeletePVCs_Call) Return(_a0 error) *Kubectl_DeletePVCs_Call {
	_c.Call.Return(_a0)
	return _c
}

// Exec provides a mock function with given fields: ktx, container, command, opts
func (_m *Kubectl) Exec(ktx kubecfg.Kubectx, container kubectl.Container, command []string, opts ...shell.RunOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ktx, container, command)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(kubecfg.Kubectx, kubectl.Container, []string, ...shell.RunOption) error); ok {
		r0 = rf(ktx, container, command, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Kubectl_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type Kubectl_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ktx kubecfg.Kubectx
//   - container kubectl.Container
//   - command []string
//   - opts ...shell.RunOption
func (_e *Kubectl_Expecter) Exec(ktx interface{}, container interface{}, command interface{}, opts ...interface{}) *Kubectl_Exec_Call {
	return &Kubectl_Exec_Call{Call: _e.mock.On("Exec",
		append([]interface{}{ktx, container, command}, opts...)...)}
}

func (_c *Kubectl_Exec_Call) Run(run func(ktx kubecfg.Kubectx, container kubectl.Container, command []string, opts ...shell.RunOption)) *Kubectl_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]shell.RunOption, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(shell.RunOption)
			}
		}
		run(args[0].(kubecfg.Kubectx), args[1].(kubectl.Container), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *Kubectl_Exec_Call) Return(_a0 error) *Kubectl_Exec_Call {
	_c.Call.Return(_a0)
	return _c
}

// ExecInteractive provides a mock function with given fields: ktx, container, command
func (_m *Kubectl) ExecInteractive(ktx kubecfg.Kubectx, container kubectl.Container, command []string) error {
	ret := _m.Called(ktx, container, command)

	var r0 error
	if rf, ok := ret.Get(0).(func(kubecfg.Kubectx, kubectl.Container, []string) error); ok {
		r0 = rf(ktx, container, command)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Kubectl_ExecInteractive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecInteractive'
type Kubectl_ExecInteractive_Call struct {
	*mock.Call
}

// ExecInteractive is a helper method to define mock.On call
//   - ktx kubecfg.Kubectx
//   - container kubectl.Container
//   - command []string
func (_e *Kubectl_Expecter) ExecInteractive(ktx interface{}, container interface{}, command interface{}) *Kubectl_ExecInteractive_Call {
	return &Kubectl_ExecInteractive_Call{Call: _e.mock.On("ExecInteractive", ktx, container, command)}
}

func (_c *Kubectl_ExecInteractive_Call) Run(run func(ktx kubecfg.Kubectx, container kubectl.Container, command []string)) *Kubectl_ExecInteractive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(kubecfg.Kubectx), args[1].(kubectl.Container), args[2].([]string))
	})
	return _c
}

func (_c *Kubectl_ExecInteractive_Call) Return(_a0 error) *Kubectl_ExecInteractive_Call {
	_c.Call.Return(_a0)
	return _c
}

// Logs provides a mock function with given fields: ktx, podSelector, option
func (_m *Kubectl) Logs(ktx kubecfg.Kubectx, podSelector map[string]string, option ...kubectl.LogsOption) error {
	_va := make([]interface{}, len(option))
	for _i := range option {
		_va[_i] = option[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ktx, podSelector)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(kubecfg.Kubectx, map[string]string, ...kubectl.LogsOption) error); ok {
		r0 = rf(ktx, podSelector, option...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Kubectl_Logs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logs'
type Kubectl_Logs_Call struct {
	*mock.Call
}

// Logs is a helper method to define mock.On call
//   - ktx kubecfg.Kubectx
//   - podSelector map[string]string
//   - option ...kubectl.LogsOption
func (_e *Kubectl_Expecter) Logs(ktx interface{}, podSelector interface{}, option ...interface{}) *Kubectl_Logs_Call {
	return &Kubectl_Logs_Call{Call: _e.mock.On("Logs",
		append([]interface{}{ktx, podSelector}, option...)...)}
}

func (_c *Kubectl_Logs_Call) Run(run func(ktx kubecfg.Kubectx, podSelector map[string]string, option ...kubectl.LogsOption)) *Kubectl_Logs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]kubectl.LogsOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(kubectl.LogsOption)
			}
		}
		run(args[0].(kubecfg.Kubectx), args[1].(map[string]string), variadicArgs...)
	})
	return _c
}

func (_c *Kubectl_Logs_Call) Return(_a0 error) *Kubectl_Logs_Call {
	_c.Call.Return(_a0)
	return _c
}

// PortForward provides a mock function with given fields: targetRelease, targetResource, targetPort
func (_m *Kubectl) PortForward(targetRelease terra.Release, targetResource string, targetPort int) (int, func() error, error) {
	ret := _m.Called(targetRelease, targetResource, targetPort)

	var r0 int
	if rf, ok := ret.Get(0).(func(terra.Release, string, int) int); ok {
		r0 = rf(targetRelease, targetResource, targetPort)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 func() error
	if rf, ok := ret.Get(1).(func(terra.Release, string, int) func() error); ok {
		r1 = rf(targetRelease, targetResource, targetPort)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(func() error)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(terra.Release, string, int) error); ok {
		r2 = rf(targetRelease, targetResource, targetPort)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Kubectl_PortForward_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PortForward'
type Kubectl_PortForward_Call struct {
	*mock.Call
}

// PortForward is a helper method to define mock.On call
//   - targetRelease terra.Release
//   - targetResource string
//   - targetPort int
func (_e *Kubectl_Expecter) PortForward(targetRelease interface{}, targetResource interface{}, targetPort interface{}) *Kubectl_PortForward_Call {
	return &Kubectl_PortForward_Call{Call: _e.mock.On("PortForward", targetRelease, targetResource, targetPort)}
}

func (_c *Kubectl_PortForward_Call) Run(run func(targetRelease terra.Release, targetResource string, targetPort int)) *Kubectl_PortForward_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(terra.Release), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *Kubectl_PortForward_Call) Return(_a0 int, _a1 func() error, _a2 error) *Kubectl_PortForward_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

// ShutDown provides a mock function with given fields: env
func (_m *Kubectl) ShutDown(env terra.Environment) error {
	ret := _m.Called(env)

	var r0 error
	if rf, ok := ret.Get(0).(func(terra.Environment) error); ok {
		r0 = rf(env)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Kubectl_ShutDown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShutDown'
type Kubectl_ShutDown_Call struct {
	*mock.Call
}

// ShutDown is a helper method to define mock.On call
//   - env terra.Environment
func (_e *Kubectl_Expecter) ShutDown(env interface{}) *Kubectl_ShutDown_Call {
	return &Kubectl_ShutDown_Call{Call: _e.mock.On("ShutDown", env)}
}

func (_c *Kubectl_ShutDown_Call) Run(run func(env terra.Environment)) *Kubectl_ShutDown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(terra.Environment))
	})
	return _c
}

func (_c *Kubectl_ShutDown_Call) Return(_a0 error) *Kubectl_ShutDown_Call {
	_c.Call.Return(_a0)
	return _c
}

type mockConstructorTestingTNewKubectl interface {
	mock.TestingT
	Cleanup(func())
}

// NewKubectl creates a new instance of Kubectl. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewKubectl(t mockConstructorTestingTNewKubectl) *Kubectl {
	mock := &Kubectl{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
